### 第 1 章：并发简介

为什么要编写并发程序 ？

1. Java 的线程使复杂的异步代码变得简单
2. 充分发挥多处理器的强大计算能力
3. 处理器数量的增长，并发编程越来越重要



#### 并发简史

1. 早期计算机没有操作系统，一个程序运行在一台机器上，不方便调度也浪费资源
2. 操作系统对于资源的分配和调度，让计算机可以运行多个程序，不同的程序在进程中运行



操作系统为计算机带来的好处（也是以下原因促使了操作系统的出现）：

1. 资源利用率：利用计算机的硬件资源
2. 公平性：不同的进程以公平的方式访问硬件资源
3. 便利性：多任务和多进程让运行程序更方便



线程和进程：

1. 促使操作系统出现的因素，也促使线程的诞生（更加细粒度的控制）
2. 线程也是轻量级进程，是操作系统基本的调度单位
3. 进程中的所有线程都将共享进程的内存地址空间



#### 线程的优势

为什么会有多线程的出现：

1. 通过提高时钟频率来提升性能已变得越来越困难（技术问题 + 摩尔定律）
2. 解决摩尔定律失效的方式就是在单芯片上放置多处理器核心



多线程带来的好处：

1. 客户端应用程序中，线程可以提高用户界面的响应灵敏度
2. 服务器应用程序中，线程可以提升资源利用率和系统吞吐量
3. 简化 JVM 的实现，GC 通常由专门的线程去运行
4. 如果程序只有一个线程，那么在 100 核处理器上，99% 资源无法利用



#### 线程带来风险

编程语言支持线程是一把双刃剑，它需要有以下的基础：

1. 语言层面需要提供支持线程的语法和库
2. 跨平台的统一内存模型，例如：JMM 内存模型
3. 对开发人员有更高的要求



##### 安全性问题

没有充足同步的情况下，多线程操作顺序不可预测，参考代码：

```java
public class UnsafeSequence {

    private int value;

    public int getNext() {
        return value++;
    }
}
```

当我们开启两个线程对它进行并发操作的时候，看看会有什么问题，如下：

```java
public static void main(String[] args) throws InterruptedException {
    Sequence sequence = new Sequence();
    Thread t1 = new Thread(() -> {
        for (int i = 0; i < 10000; i++) {
            // value + 10000
            sequence.getNext();
        }
    });

    Thread t2 = new Thread(() -> {
        for (int i = 0; i < 10000; i++) {
            // value + 10000
            sequence.getNext();
        }
    });
    t1.start(); t2.start();
    t1.join(); t2.join();
    System.out.println(sequence.value);
}
```

我们预期输出的 20000，但实际输出后的结果如下（不可预测）：

```sh
18649
```

该错误出现原因是：虽然递增运算 `value++` 是单操作，但它包含三个独立操作，如下：

1. 读取 value
2. 将 value + 1
3. 将计算结果写入 value

结论是：两个线程可能同时执行读操作，拿到相同的值加 1。所以产生错误的结果。上面的例子说明的是一种常见的并发安全问题，称为 **竞态条件 Race Condition**。执行情况如下图：  



<img src="https://pcloud-1258173945.cos.ap-guangzhou.myqcloud.com/uPic/image-20220309134502430.png" alt="image-20220309134502430" style="zoom: 33%;" />

  

安全性总结：

1. 由于多个线程要共享相同的内存地址空间，这带来了极大的便利性，但也存在极大的风险
2. 多线程的使用会由于无法预料的数据变化而发生无法预测的错误行为
3. 要使多线程的行为可以预测，必须对共享变量进行同步处理，避免相互干扰
4. Java 语言提供各种同步机制来协同这种访问，如下



将 `getNext` 修改为同步方案来解决程序错误的问题，代码如下：

```java
public class Sequence {

    private int value;

    public synchronized int getNext() {
        return value++;
    }
}
```

输出结果：

```sh
20000
```



##### 其他问题

1. 活跃性问题：典型的活跃性问题：死锁，饥饿，活锁
2. 性能问题：线程调度器产生的 **上下文切换 Context Swtich** 开销



#### 线程无处不在

不要以为工作中用不到多线程，就可以不用去学多线程，它在工作中其实无处不在：

1. 即使在程序中没有创建线程，但是框架中仍可能会创建线程
2. Java 程序启动时，JVM 会创建后台线程和主线程
3. Servlet，JSP 通过多线程来响应客户端的请求
4. RMI 远程方法调用，实际上是在 RMI 管理的线程中调用对象的
5. Swing，AWT，单独的线程来处理用户的触发事件



### 第 2 章：线程安全性

