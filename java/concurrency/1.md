### 第 1 章：并发简介

为什么要编写并发程序 ？

1. Java 的线程使复杂的异步代码变得简单
2. 充分发挥多处理器的强大计算能力
3. 处理器数量的增长，并发编程越来越重要



#### 并发简史

1. 早期计算机没有操作系统，一个程序运行在一台机器上，不方便调度也浪费资源
2. 操作系统对于资源的分配和调度，让计算机可以运行多个程序，不同的程序在进程中运行



操作系统为计算机带来的好处（也是以下原因促使了操作系统的出现）：

1. 资源利用率：利用计算机的硬件资源
2. 公平性：不同的进程以公平的方式访问硬件资源
3. 便利性：多任务和多进程让运行程序更方便



线程和进程：

1. 促使操作系统出现的因素，也促使线程的诞生（更加细粒度的控制）
2. 线程也是轻量级进程，是操作系统基本的调度单位
3. 进程中的所有线程都将共享进程的内存地址空间



#### 线程的优势

为什么会有多线程的出现：

1. 通过提高时钟频率来提升性能已变得越来越困难（技术问题 + 摩尔定律）
2. 解决摩尔定律失效的方式就是在单芯片上放置多处理器核心



多线程带来的好处：

1. 客户端应用程序中，线程可以提高用户界面的响应灵敏度
2. 服务器应用程序中，线程可以提升资源利用率和系统吞吐量
3. 简化 JVM 的实现，GC 通常由专门的线程去运行
4. 如果程序只有一个线程，那么在 100 核处理器上，99% 资源无法利用



#### 线程带来风险

编程语言支持线程是一把双刃剑，它需要有以下的基础：

1. 语言层面需要提供支持线程的语法和库
2. 跨平台的统一内存模型，例如：JMM 内存模型
3. 对开发人员有更高的要求



##### 安全性问题

没有充足同步的情况下，多线程操作顺序不可预测，参考代码：

```java
public class UnsafeSequence {

    private int value;

    public int getNext() {
        return value++;
    }
}
```

当我们开启两个线程对它进行并发操作的时候，看看会有什么问题，如下：

```java
public static void main(String[] args) throws InterruptedException {
    Sequence sequence = new Sequence();
    Thread t1 = new Thread(() -> {
        for (int i = 0; i < 10000; i++) {
            // value + 10000
            sequence.getNext();
        }
    });

    Thread t2 = new Thread(() -> {
        for (int i = 0; i < 10000; i++) {
            // value + 10000
            sequence.getNext();
        }
    });
    t1.start(); t2.start();
    t1.join(); t2.join();
    System.out.println(sequence.value);
}
```

我们预期输出的 20000，但实际输出后的结果如下（不可预测）：

```sh
18649
```

该错误出现原因是：虽然递增运算 `value++` 是单操作，但它包含三个独立操作，如下：

1. 读取 value
2. 将 value + 1
3. 将计算结果写入 value

结论是：两个线程可能同时执行读操作，拿到相同的值加 1。所以产生错误的结果。上面的例子说明的是一种常见的并发安全问题，称为 **竞态条件 Race Condition**。执行情况如下图：  



<img src="https://pcloud-1258173945.cos.ap-guangzhou.myqcloud.com/uPic/image-20220309134502430.png" alt="image-20220309134502430" style="zoom: 33%;" />

  

安全性总结：

1. 由于多个线程要共享相同的内存地址空间，这带来了极大的便利性，但也存在极大的风险
2. 多线程的使用会由于无法预料的数据变化而发生无法预测的错误行为
3. 要使多线程的行为可以预测，必须对共享变量进行同步处理，避免相互干扰
4. Java 语言提供各种同步机制来协同这种访问，如下



将 `getNext` 修改为同步方案来解决程序错误的问题，代码如下：

```java
public class Sequence {

    private int value;

    public synchronized int getNext() {
        return value++;
    }
}
```

输出结果：

```sh
20000
```



##### 其他问题

1. 活跃性问题：典型的活跃性问题：死锁，饥饿，活锁
2. 性能问题：线程调度器产生的 **上下文切换 Context Swtich** 开销



#### 线程无处不在

不要以为工作中用不到多线程，就可以不用去学多线程，它在工作中其实无处不在：

1. 即使在程序中没有创建线程，但是框架中仍可能会创建线程
2. Java 程序启动时，JVM 会创建后台线程和主线程
3. Servlet，JSP 通过多线程来响应客户端的请求
4. RMI 远程方法调用，实际上是在 RMI 管理的线程中调用对象的
5. Swing，AWT，单独的线程来处理用户的触发事件



### 第 2 章：线程安全性

线程安全的定义：

1. 线程和锁 🔐 的作用在并发编程中，类似铆钉和工字梁在土木工程中的作用。要建筑一座坚固的桥梁，必须正确地使用大量的铆钉和工字梁。（起到稳定和保证有序的作用）
2. 编写线程安全的代码，其核心在于要对状态访问操作进行管理，特别是：
   -  共享的 （Shared）：可以由多个线程同事访问
   - 可变的（Mutable）：变量的值在其声明周期内发生变化
3. 当多线程访问有状态变量，必须使用同步机制来协同线程对变量的访问，Java 主要同步机制是 sunchronized，但是还包含：volatile 类型变量，显式锁 Explicit Lock，原子变量



修复线程安全问题的三种方式：

1. 不在线程之间共享状态变量
2. 将状态变量修改为不可变的变量
3. 在访问变量时使用同步



#### 什么是线程安全性

1. 在线程安全性的定义中，最核心的概念就是正确性，含义就是类的行为与规范和预期一直
2. 在多线程访问类的时，类时钟都能表现正确的行为，那么这个类就是线程安全的
3. 线程访问无状态对象不会影响其他线程操作的正确性，因为无状态对象是线程安全的
4. 只有当程序处理请求需要保存一些状态信息，那么才会出现线程安全的问题
5. 如果用多线程去处理一段很少执行的代码，想去提升性能，那么将会得不偿失



#### 竞态条件

1. 当某个计算正确性取决于多线程的交替执行时序，那么会发现竞态条件
2. 最常见的竞态条件类型就是 先检查后执行 **Check-Then-Act** 操作



一个关于竞态条件，很经典的例子：

<img src="https://pcloud-1258173945.cos.ap-guangzhou.myqcloud.com/uPic/image-20220310111927033.png" alt="image-20220310111927033" style="zoom:50%;" />

这里例子说明一种竞态条件：因为要获得正确的结果，必须取决于事件发生时序



#### 复合操作

1. 要避免竞态条件问题，就必须在线程修改变量时，通过同步机制防止其他线程使用该变量
2. 原子操作是指对于访问一个状态的所有操作（包括操作本身），是一个不可修改的整体
3. `java.util.concurrent.atomic` 提供很多原子变量，用于实现在数值和对象引用的原子状态转换
   - 例如：通过 `AtomicLong` 来代替 `long` 类型的计算器，可以确保所有对计数器的访问都是原子的
4. 尽可能的使用线程安全对象，例如 `AtomicLong` 和相关的包来管理类的状态
5. `AtomicLong` 是 long 类型的线程安全类，类似 HashTable 是 HashMap 的线程安全类（这么说似乎也不很全面）



#### 内置锁

Java 提供一种内置的锁机制来支持原子，同步代码块 Synchronized Block：

1. 互斥锁，最多只有一个线程独占锁，粒度比较粗，适合比较简单的并发场景
2. Synchronized 解决了同步的问题，却引入的性能问题（多核变单核）
3. Synchronized 会自动为代码块执行 `lock`，`unlock` 操作，自动化，可读性好
4. 重入锁是通过计数器来实现的，初始值为 0，加锁一次，计数器 +1，退出锁需要相应的递减
5. 重入是锁实现的另一种补充，简化了面向对象并发开发的难度



### 第 3 章：对象的共享



