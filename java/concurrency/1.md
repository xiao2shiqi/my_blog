### 第 1 章：并发简介

为什么要编写并发程序 ？

1. Java 的线程使复杂的异步代码变得简单
2. 充分发挥多处理器的强大计算能力
3. 处理器数量的增长，并发编程越来越重要



#### 并发简史

1. 早期计算机没有操作系统，一个程序运行在一台机器上，不方便调度也浪费资源
2. 操作系统对于资源的分配和调度，让计算机可以运行多个程序，不同的程序在进程中运行



操作系统为计算机带来的好处（也是以下原因促使了操作系统的出现）：

1. 资源利用率：利用计算机的硬件资源
2. 公平性：不同的进程以公平的方式访问硬件资源
3. 便利性：多任务和多进程让运行程序更方便



线程和进程：

1. 促使操作系统出现的因素，也促使线程的诞生（更加细粒度的控制）
2. 线程也是轻量级进程，是操作系统基本的调度单位
3. 进程中的所有线程都将共享进程的内存地址空间



#### 线程的优势

为什么会有多线程的出现：

1. 通过提高时钟频率来提升性能已变得越来越困难（技术问题 + 摩尔定律）
2. 解决摩尔定律失效的方式就是在单芯片上放置多处理器核心



多线程带来的好处：

1. 客户端应用程序中，线程可以提高用户界面的响应灵敏度
2. 服务器应用程序中，线程可以提升资源利用率和系统吞吐量
3. 简化 JVM 的实现，GC 通常由专门的线程去运行
4. 如果程序只有一个线程，那么在 100 核处理器上，99% 资源无法利用



#### 线程带来风险

编程语言支持线程是一把双刃剑，它需要有以下的基础：

1. 语言层面需要提供支持线程的语法和库
2. 跨平台的统一内存模型，例如：JMM 内存模型
3. 对开发人员有更高的要求



**安全性问题**

没有充足同步的情况下，多线程操作顺序不可预测，参考代码：

```java
public class UnsafeSequence {

    private int value;

    public int getNext() {
        return value++;
    }
}
```

当我们开启两个线程对它进行并发操作的时候，看看会有什么问题，如下：

```java
public static void main(String[] args) throws InterruptedException {
    Sequence sequence = new Sequence();
    Thread t1 = new Thread(() -> {
        for (int i = 0; i < 10000; i++) {
            // value + 10000
            sequence.getNext();
        }
    });

    Thread t2 = new Thread(() -> {
        for (int i = 0; i < 10000; i++) {
            // value + 10000
            sequence.getNext();
        }
    });
    t1.start(); t2.start();
    t1.join(); t2.join();
    System.out.println(sequence.value);
}
```

我们预期输出的 20000，但实际输出后的结果如下（不可预测）：

```sh
18649
```

该错误出现原因是：虽然递增运算 `value++` 是单操作，但它包含三个独立操作，如下：

1. 读取 value
2. 将 value + 1
3. 将计算结果写入 value

结论是：两个线程可能同时执行读操作，拿到相同的值加 1。所以产生错误的结果。上面的例子说明的是一种常见的并发安全问题，称为 **竞态条件 Race Condition**。执行情况如下图：  



<img src="https://pcloud-1258173945.cos.ap-guangzhou.myqcloud.com/uPic/image-20220309134502430.png" alt="image-20220309134502430" style="zoom: 33%;" />

  

安全性总结：

1. 由于多个线程要共享相同的内存地址空间，这带来了极大的便利性，但也存在极大的风险
2. 多线程的使用会由于无法预料的数据变化而发生无法预测的错误行为
3. 要使多线程的行为可以预测，必须对共享变量进行同步处理，避免相互干扰
4. Java 语言提供各种同步机制来协同这种访问，如下



将 `getNext` 修改为同步方案来解决程序错误的问题，代码如下：

```java
public class Sequence {

    private int value;

    public synchronized int getNext() {
        return value++;
    }
}
```

输出结果：

```sh
20000
```



**其他问题**

1. 活跃性问题：典型的活跃性问题：死锁，饥饿，活锁
2. 性能问题：线程调度器产生的 **上下文切换 Context Swtich** 开销



#### 线程无处不在

不要以为工作中用不到多线程，就可以不用去学多线程，它在工作中其实无处不在：

1. 即使在程序中没有创建线程，但是框架中仍可能会创建线程
2. Java 程序启动时，JVM 会创建后台线程和主线程
3. Servlet，JSP 通过多线程来响应客户端的请求
4. RMI 远程方法调用，实际上是在 RMI 管理的线程中调用对象的
5. Swing，AWT，单独的线程来处理用户的触发事件



### 第 2 章：线程安全性

线程安全的定义：

1. 线程和锁 🔐 的作用在并发编程中，类似铆钉和工字梁在土木工程中的作用。要建筑一座坚固的桥梁，必须正确地使用大量的铆钉和工字梁。（起到稳定和保证有序的作用）
2. 编写线程安全的代码，其核心在于要对状态访问操作进行管理，特别是：
   -  共享的 （Shared）：可以由多个线程同事访问
   - 可变的（Mutable）：变量的值在其声明周期内发生变化
3. 当多线程访问有状态变量，必须使用同步机制来协同线程对变量的访问，Java 主要同步机制是 sunchronized，但是还包含：volatile 类型变量，显式锁 Explicit Lock，原子变量



修复线程安全问题的三种方式：

1. 不在线程之间共享状态变量
2. 将状态变量修改为不可变的变量
3. 在访问变量时使用同步



#### 什么是线程安全性

1. 在线程安全性的定义中，最核心的概念就是正确性，含义就是类的行为与规范和预期一直
2. 在多线程访问类的时，类时钟都能表现正确的行为，那么这个类就是线程安全的
3. 线程访问无状态对象不会影响其他线程操作的正确性，因为无状态对象是线程安全的
4. 只有当程序处理请求需要保存一些状态信息，那么才会出现线程安全的问题
5. 如果用多线程去处理一段很少执行的代码，想去提升性能，那么将会得不偿失



#### 竞态条件

1. 当某个计算正确性取决于多线程的交替执行时序，那么会发现竞态条件
2. 最常见的竞态条件类型就是 先检查后执行 **Check-Then-Act** 操作



一个关于竞态条件，很经典的例子：

<img src="https://pcloud-1258173945.cos.ap-guangzhou.myqcloud.com/uPic/image-20220310111927033.png" alt="image-20220310111927033" style="zoom:50%;" />

这里例子说明一种竞态条件：因为要获得正确的结果，必须取决于事件发生时序



#### 复合操作

1. 要避免竞态条件问题，就必须在线程修改变量时，通过同步机制防止其他线程使用该变量
2. 原子操作是指对于访问一个状态的所有操作（包括操作本身），是一个不可修改的整体
3. `java.util.concurrent.atomic` 提供很多原子变量，用于实现在数值和对象引用的原子状态转换
   - 例如：通过 `AtomicLong` 来代替 `long` 类型的计算器，可以确保所有对计数器的访问都是原子的
4. 尽可能的使用线程安全对象，例如 `AtomicLong` 和相关的包来管理类的状态
5. `AtomicLong` 是 long 类型的线程安全类，类似 HashTable 是 HashMap 的线程安全类（这么说似乎也不很全面）



#### 内置锁

Java 提供一种内置的锁机制来支持原子，同步代码块 Synchronized Block：

1. 互斥锁，最多只有一个线程独占锁，粒度比较粗，适合比较简单的并发场景
2. Synchronized 解决了同步的问题，却引入的性能问题（多核变单核）
3. Synchronized 会自动为代码块执行 `lock`，`unlock` 操作，自动化，可读性好
4. 重入锁是通过计数器来实现的，初始值为 0，加锁一次，计数器 +1，退出锁需要相应的递减
5. 重入是锁实现的另一种补充，简化了面向对象并发开发的难度



### 第 3 章：对象的共享

要点：

1. 正确的并发程序的定义：对多线程在访问的可变状态时需要进行正确的管理
2. **内存可见性 Memory Visibility** 也是同步的一个重要环节
3. 关于可见性的定义：当一个线程修改了对象状态后，其他线程能够看到发生的状态变化



#### 可见性

因为无法保证读值的时候不被其他线程写入，因为**为了保证可见性，必须使用同步机制**

如下程序说明在没有同步的情况下，共享数据时出现的错误：

```java
public class NoVisibility {

    private static boolean ready;
    private static int number;

    private static class ReaderThread extends Thread {
        @Override
        public void run() {
            // 检测到变量修改，输出 number...
            while (!ready) {
                Thread.yield();
                System.out.println(number);
            }
        }
    }

    public static void main(String[] args) {
        ReaderThread thread = new ReaderThread();
        thread.start();
        number = 42;
        ready = true;
    }
}
```

运行结果会出现以下几种情况：

1. NoVisibility 一直持续循环下去，因为读线程无法观测到 ready 的变更
2. NoVisibility 会输出 0，因为读线程看到了写入 ready 的值，却没有看到 `number` 的值
3. …………



结论：

1. 在缺乏足够同步的多线程程序中，要想对内存操作的执行顺序进行判断，几乎无法得出正确的值
2. 数据库的四种隔离级别，无非都是牺牲准确性获取性能的提升（从高 -> 低）



#### 加锁和可见性

通过同步保证变量可见性的示例图：

<img src="https://pcloud-1258173945.cos.ap-guangzhou.myqcloud.com/uPic/image-20220317153141591.png" alt="image-20220317153141591" style="zoom:50%;" />

1. 在访问共享变量时要求所有线程在一个锁上同步，就是为了确保变量的可见性
2. 加锁的含义不仅仅局限于互斥行为，还包括内存可见性（2 点）



#### Volatile 变量

volatile 是什么 ？

1. volatile 是一种比较弱的同步机制，用于确保变量更新后通知其他线程
2. volatile 不会加锁，也不会阻塞，是一种比 synchronized 更轻量级的同步机制
3. volatile 的大多数场景是：标记某个状态（操作完成，中断，执行中）等，是否退出循环



为什么不推荐过分依赖 volatile ？

1. 通过 volatile 保证变量可见性，会比使用锁更脆弱，也更难理解，**不建议过分依赖**
2. 锁可以保证可见性，又可以保证原子性，volatile 只能保证可见性，而且同步机制的可见性更强



#### 线程封闭

什么是线程封闭 ？

1. 因为共享对象，所以需要同步机制保证顺利，还有一种避免产生竞态条件的方法，就是 Thread Confinement
2. 线程封闭的本质就是给所有线程分配一个私有独立的对象，避免线程争抢公共资源
3. Java 提供局部变量和 ThreadLocal 来实现线程封闭的特性



**ThreadLocal 类**

1. 维持线程封闭的规范方法是使用 ThreadLocal 类，该类为每条线程保存一份独立副本
2. `get()` 方法总是返回由当前执行线程在调用 `set()` 时设置的最新值
3. 从概念上看，可以将 `ThreadLocal<T>` 看做包含 `Map<Thread, T>` 线程和对象的容器



**不变性 Immutable**

不可变对象天生满足线程安全的特点，换言之，不可变对象一定是线程安全的（感觉有点废话，不能修改的东西，肯定是安全的）。

满足对象不可变的条件：

1. 对象创建后不可改变
2. 所有域都是 final 类型
3. 对象是正确创建的



**final 关键字**

1. `final` 关键字是由于构建不可变 Immutable 的对象
2. `final` 还能保证对象初始化的安全性，保证共享 final 对象无需进行同步



### 第 4 章：对象的组合





