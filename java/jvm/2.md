## Java 内存区域和内存溢出

### 运行时数据区域

Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域，各自区域有各自的用途，JVM 内存区域总览（如图）：

<img src="https://pcloud-1258173945.cos.ap-guangzhou.myqcloud.com/uPic/D08bIm.png" alt="D08bIm" style="zoom:33%;" />

下面会讲解虚拟机各个区域的具体职责和功能划分



#### 程序计数器

程序计数器（Program Counter Register）是一块较小的内存空间

程序计数器的作用：

* 线程所执行的字节码的行号指示器
* 为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器
* 程序计数器占用的内存是线程私有的内存



#### 虚拟机栈 VM Stack

* 虚拟机栈描述的是 Java 方法执行的线程内存模型
* 每个方法被执行的时候虚拟机都会同步创建一个栈帧，保存局部变量表，操作数栈，动态链接等信息



虚拟机中常见两种内存区域异常有一个就来源于此，具体是：

* 线程请求的栈深度（方法调用）大于虚拟机所允许的深度，就会抛出 StackOverFlowError 异常
* 虚拟机内存容量可以动态扩容，当虚拟机无法申请到足够的内存就会抛出 OutOfMemoryError 异常



#### 本地方法栈

本地方法栈（Native Method Stack）类似 VM Stack（虚拟机栈），不同的是 VM Stack 服务对象是虚拟机执行的 Java 方法，而本地方法栈则是为虚拟机使用的本地方法（Native Method ）提供服务。

因为本地方法（Native Method）日常使用非常少，大多数的 Native Method 都是 Unsafe 操作，所以大概了解就好了。

另外需要注意的是本地方法栈区域同样会因为内存不足而抛出 StackOverFlowError 和 OutOfMemoryError 异常



####  堆空间 Heap

Java 堆空间的特点：

1. 堆空间 Heap 虚拟机所管理的最大的一块内存区域，被所有线程共享使用
2. Java 世界里面几乎所有的对象实例都在这里分配内存
3. Java GC 垃圾收集器重点关照的内存区域，所以堆是基于分代理论设计的，**但目前很多虚拟机已经不采用分代的设计了**
4. 堆空间的分代设计，还是细分的目的都是为了更好，更快的回收内存
5. 堆空间可以通过（-Xmx 和 -Xms 设定固定大小），但默认的实现是可扩展的，并且当堆空间无法再扩展内存的时候，虚拟机就会抛出 OutOfMemoryError 异常



新生代（一个 Eden 和两个 Survivor 区域）、老年代这种划分，历史上有许多款虚拟机采用这种设计，包括 HotSpot 和它的前身 Self、StrongTalk 虚拟机，源自 UC Berkeley 在 20 世纪 80 年代中期开发的 Berkeley Smalltalk



#### 方法区

方法区 Method Area 区域的特点：

1. 主要用于存储被虚拟机加载的类型信息，常量，静态变量，即时编译器编译后的代码缓存等数据
2. 跟堆 Heap 空间一样，是各个线程共享的内存区域



经常有人会把方法区和永久代混淆，两者完全是不同的概念，这里有必要解释一下：

永久代更容易导致内存溢出的问题，例如 String::intern()，所以JDK 8 完全废弃永久代的概念，在本地内存中实现元空间（Meta-Space）来代替。



方法区内部的运行时常量池的作用

* 用于存放编译期生成的各种字面量于符号引用
* 开发人员经常利用 String 类的 intern() 方法在运行时常量池缓存字符
* 当常量池无法再申请内存时会抛出 OutOfMemoryError 异常



#### 直接内存

Direct Memory 不属于虚拟机的一部分，但是如果频繁使用也会出现 OutOfMemoryError 异常，Direct Memory 的常见场景是在 JDK 1.4 中心加入的 NIO 类，它可以使用  Native 函数库直接分配堆外内存。



Direct Memory 的优缺点：

优点：直接分配内存不受 Java 堆大小的限制

缺点：容易被忽略，导致动态扩展的时候出现 OOM 异常



###  HotSpot 对象揭秘

#### 对象的创建过程

在语言层面创建对象仅仅是一个 `new` 关键字而已，但是在虚拟机中对象入如何创建的呢？

虚拟机创建对象的五个步骤：

1. 虚拟机遇到 `new` 指令的时候，首先会检查类的加载，解析和初始化情况（我们假设类已经被加载，后续再探讨类的加载过程）
2.  然后就是为对象在 Java 堆中分配内存，虚拟机必须将分配到内存空间的对象初始化为零值（如果使用 TLAB 的话，这一项工作也可以提前至 TLAB 分配时顺便进行）
2.  为对象进行必要的设置，例如：类的实例，哈希码，对象的 GC 分代年龄等，这些信息存在对象的 Object Header 中
2.  虚拟机构建新的对象后，Class 文件中的 `init()` 方法还没执行，所有字段都是零值
2.  new 指令之后会借着执行  `init()` 方法，按照程序员的意愿进行对象初始化，真正的对象此时才算被构造出来



#### 对象的内存布局

在 HotSpot 虚拟机内，对象的布局为三部分：

- 对象头 Header （对象头包括两类信息）
  - 存储对象自身的运行时数据：哈希吗 HashCode，GC 分代年龄，锁状态标志，线程持有的锁，偏向线程 ID，偏向时间戳等
  - 类型指针：类型的元数据指针，Java 虚拟机通过这个指针来确定对象类的实例

- 实例数据 Instance Data：对象真正有效的信息，程序代码中所定义各种类型的字段内容

- 对齐填充 Padding：HotsSpot 要求任何对象的大小都必须是 8 字节的整数倍，所以实例数据没有对齐的话，就需要通过对齐填充来补全





#### 对象的访问

创建对象的目的自然是为了访问和使用，主流的访问方式主要有使用句柄和直接指针两种：

第一种：使用句柄（极少使用，不推荐）

在堆中划分内存作为句柄池，栈中存储句柄地址，句柄池中存储对象的具体地址

优点：reference 存储地址问稳定，就算对象移动，只会修改句柄指针，reference 无需修改

缺点：性能差

如图：

<img src="https://pcloud-1258173945.cos.ap-guangzhou.myqcloud.com/uPic/image-20220219154806153.png" alt="image-20220219154806153" style="zoom:33%;" />

第二种：直接指针（常用）

直接在 reference 中存储对象地址，可以直接访问对象，不需要多一次间接访问的开销，因为在 Java 中对象的访问极其的频繁，因此这类开销也是一项极其客观的执行成本

<img src="https://pcloud-1258173945.cos.ap-guangzhou.myqcloud.com/uPic/image-20220219155203617.png" alt="image-20220219155203617" style="zoom:33%;" />

### OOM 最佳实践

实践 OOM 的两个目的：

* 验证 Java 虚拟机描述各个区域的存储内容
* 遇到内存溢出时候，可以迅速的得知是哪个区域的溢出问题



#### Java 堆溢出

Java 堆内存的 OOM 应该是实际应用中最常见的内存异常情况，触发堆 OOM 的前置条件是：

1. 不停的创建对象
2. 保证 GC Roots 到对象之间有可达路径来摆满垃圾回收
3. 对着对象数量的触发，就会产生内存溢出



一段可以触发 OOM 的代码：

VM 参数：`VM Args: -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/Users/xiaobin/Downloads/java_heapdump.hprof`

```java
public class HeapOOM {

    static class OOMObject {
    }

    public static void main(String[] args) {
        List<OOMObject> list = new ArrayList<>();
        while (true) {
            list.add(new OOMObject());
        }
    }
}
```

运行结果：

```sh
java.lang.OutOfMemoryError: Java heap space
Dumping heap to /Users/xiaobin/Downloads/java_heapdump.hprof ...
Heap dump file created [29193688 bytes in 0.131 secs]
Exception in thread "main" java.lang.OutOfMemoryError: Java heap space
```



提供两个解决堆 OOM 的思路：

1. 如果是内存泄漏，使用 MAT 查看对象到 GC Roots 的引用链，找到对象无法被 GC 回收的原因，从而定位问题
2. 如果是内存不足，检查虚拟机的堆参数（-Xmx 与 - Xms）设置和机器内存对比，上调代码。再检查代码，减少设计不合理的情况



#### 虚拟机栈溢出

栈溢出的第一种情况：

线程请求的栈深度大于虚拟机所允许的最大深度，会抛出 StackOverflowError 异常，如下：

```java
public class JavaVMStackSOF {

    private int stackLength = 1;

    public void stackLeak() {
        stackLength++;
        stackLeak();
    }

    public static void main(String[] args) throws Throwable {
        JavaVMStackSOF oom = new JavaVMStackSOF();
        try {
            // 不停的调用自己，直到产生 StackOverFlowError
            oom.stackLeak();
        } catch (Throwable e) {
            System.out.println("stack length:" + oom.stackLength);
            throw e;
        }
    }
}
```

输出结果：

```sh
stack length:498
Exception in thread "main" java.lang.StackOverflowError
	at JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:10)
```

结论：当新的栈帧内存无法分配的时候，HotSpot 虚拟机抛出的都是 StackOverflowError 异常。如果使用 HotSpot 虚拟机默认参数，栈深度在大多数情况下达到 1000~2000 是没问题的，对于正常的方法调用是完全够用的。



栈溢出的第二种情况：

创建线程导致内存溢出：VM 参数：`-Xss2M`

```java
public class JavaVMStackOOM {

    private void dontStop() {
        while(true) {
        }
    }

    public void stackLeakByThread() {
        while (true) {
            Thread thread = new Thread(() -> dontStop());
            thread.start();
        }
    }

    public static void main(String[] args) {
        JavaVMStackOOM oom = new JavaVMStackOOM();
        oom.stackLeakByThread();
    }
}
```

执行结果：

```sh
Exception in thread "main" java.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached
	at java.base/java.lang.Thread.start0(Native Method)
	at java.base/java.lang.Thread.start(Thread.java:803)
```



#### 方法区和运行时常量池溢出

运行时常量池溢出主要原因：

JDK 7 以前主要是 `String::intern()` 会将对象添加到常量池中，如果处理不当容易出现 OOM。但是 JDK 7 开始逐步去永久代的计划，并在 JDK 8 中使用元空间来代替。所以 JDK 7 及以上的版本大多不需要担心该问题。



方法区溢出的主要原因：

方法区主要是存放类型的信息，类名，访问修饰符，常量池，字段描述，方法描述等。目前很多主流框架，例如 Spring，Hibernate 对类进行增强时，都会使用 CGLib 这类字节码结束，当增强的类越多，就需要越大的方法区保证动态生成的类型可以载入内存。



#### 本机直接内存溢出

直接内存使用 `-XX:MaxDirectMemorySize` 参数设置，默认与 Java 堆最大值相同 `-Xmx 指定`，以下代码是通过 **Unsafe** 类操作堆外内存，最终导致直接内存溢出，代码如下:

```java
public class DirectMemoryOOM {

    public static final int _1MB = 1024 * 1024;

    public static void main(String[] args) throws Exception {
        Field unsafeField = Unsafe.class.getDeclaredFields()[0];
        unsafeField.setAccessible(true);
        Unsafe unsafe = (Unsafe) unsafeField.get(null);
        while (true) {
            unsafe.allocateMemory(_1MB);
        }
    }
}
```

程序有以下几个特征，就可以重点检查直接内存了：

* Heap Dump 文件中没有明显异常情况，或者 Dump 文件很小
* 程序中直接或间接的使用了 DirectMemory（间接使用 NIO）

---

## 垃圾收集器和内存分配

1960 年诞生于 MIT（麻省理工学院）的 Lisp 是第一门使用内存动态分配和垃圾收集（Garbage Collection）技术的语言，经过半个时机的发展，内存动态分配和内存回收的技术 ♻️ 已经发展的非常成熟了，所以我们本章就来探讨关于内存分配和垃圾收回的技术。



### 对象回收策略

需要回收♻️对象就要判断，对象是否 “存活”



#### 引用计数法

非常简单高效的判断对象存活的方法，它的算法过程是：

1. 每个对象都有一个引用计数器，在被引用的时候 + 1
2. 当引用失效时候，计数器值就 - 1
3. 当计数器为 0 则代表对象可以被回收



但是，主流的 Java 虚拟机都没有选用引用计数器来管理内存，因为对象引用有很多例外情况需要考虑，例如最简单的对象循环引用的问题，引用计数法就无法解决该问题。



我们可以通过一段代码来证实 JVM 并没有采用 引用计数法，代码如下：

```java
public class ReferenceCountingGC {

    public Object instance = null;
    public static final int _1MB = 1024 * 1024;
    private byte[] bigSize = new byte[2 * _1MB];

    public static void testGC() {
        ReferenceCountingGC objA = new ReferenceCountingGC();
        ReferenceCountingGC objB = new ReferenceCountingGC();
        objA.instance = objB;
        objB.instance = objA;
        objA = null;
        objB = null;
        // 执行 GC
        System.gc();
    }
}
```

执行结果：

```sh
[0.004s][warning][gc] -XX:+PrintGC is deprecated. Will use -Xlog:gc instead.
[0.012s][info   ][gc] Using G1
[0.176s][info   ][gc] GC(0) Pause Full (System.gc()) 8M->0M(8M) 4.461ms
```

结论：可以看到回收数据，GC 从 8M - 0M 进行的回收，没有因为循环引用就放弃回收，侧面证明虚拟机不是通过引用计数法来判断的



#### 可达性分析算法

目前主流的商用程序语言都是工作可达性分析算法来判定对象是否存活。它的工作原理大概如下：

1. 通过一系列称为 GC Roots 根对象作为起始节点集，从这些节点开始根据引用关系向下搜索
2. 搜索过的路径称为 **引用链** （Reference Chain），如果对象到 GC Roots 没有引用链，则证明对象不可达
3. 当对象不可达后，则虚拟机会将对象标记 📌  为可回收对象



例如 object 5，object 6，object 7 虽然有引用关系，但是跟 GC Roots 没有引用链，也会被回收的对象，如图：

<img src="https://pcloud-1258173945.cos.ap-guangzhou.myqcloud.com/uPic/image-20220219213417868.png" alt="image-20220219213417868" style="zoom:33%;" />

既然 GC Roots 这么重要，那么在 Java 虚拟机里哪些固定可作为 GC Roots 的对象呢 ？如下：

1. 虚拟机栈中的引用对象
2. 方法区中的引用对象
3. 本地方法栈中的 JNI 对象
4. 虚拟机内部的引用，还有系统类加载器
5. 被同步锁 synchronized 持有的对象
6. 虚拟机内部的 JMXBean，JVMTI 回调，本地缓存等



#### Java 引用类型

早在 JDK 1.2 以前，引用状态只有简单粗暴的 “被引用” 和 “未被引用” 两种状态。但实际的场景却不允许我们如此简单粗暴的定义对象的引用类型，例如我们希望有一些对象：当内存空间还足够的时候能保存在内存里，内存空间不足的时候可以抛弃这些对象。这在很多缓存场景下都很适合，于是在 JDK 1.2 以后 Java 扩充了引用的范围，具体可以分为：

1. 强引用：普遍存在的引用类型，类似 `Object obj = new Object()` 这种，是 GC 不会回收的引用对象
2. 软引用：非必须对象，在内存要溢出前虚拟机会尝试回收这些对象，如果还没有足够内存才会抛出异常，软引用可以通过 SoftReference 类来实现
3. 弱引用：非必须对象，存在感更弱，只要 GC 开始工作，不管当前内存是否足够，都会把弱引用回收掉，弱引用可以通过 WeakReference 来实现
4. 虚引用：最没存在感的对象，无法通过虚引用来获取对象实例，设置虚引用的目的只为在 GC 照顾的时候收到一个回调而已，虚引用可以通过 PhantomReference 来实现



#### 特殊公民 finalize()

`finalize()` 在 GC 工作中非常特殊，主要有以下几点可以体现：

1. 就算对象 GC Roots 不可达，只有对象有必须执行的 `finalize()` 方法，那么对象短期内不会被回收
2. 这些对象会被特殊照顾，放到一个名为 F-Queue() 队列中，由一个低优先级的 Finalizer 线程去执行它们
3. 如果某个对象的 `finalize()` 逻辑缓慢，或者死循环。可能导致 F-Queue() 队列永久等待，甚至内存回收子系统崩溃
4. 对象可以在 `finalize()` 中重新跟 GC Roots 建立联系，从而逃脱被回收的命运，当然这也是最后一次机会



关于使用 `finalize()` 的几个建议：

1. 不鼓励在 `finalize()` 中通过重新建立 GC Roots 拯救对象，避免使用它
2. `finalize()` 来源于 C，C++ 中的析构函数，是 Java 照顾传统 C，C++ 程序员做出的妥协
3. `finalize()` 运行代价高昂，不确定性打，无法保证调用顺序，已被官方声明不推荐使用
4. 很多教材中说 `finalize()`  使用用于关闭资源的工作，`finalize()` 所有能完成的工作，try-finally 都能做的更好
5. 建议大家忘记 `finalize()` 的存在。



#### 回收方法区

关于方法区的回收这里就不详细探讨了，因为回收的性价比非常低，主要原因有：

1. 《Java 虚拟机规范》可以不要求虚拟机在方法区中实现垃圾收集器，例如 JDK 11 的 ZGC 收集器就不支持类卸载
2. 在堆中，尤其在新生代中，一次常规的 GC 就可以回收 70-99% 的内存空间，相比之下，回收方法区性价比非常低



### 垃圾收集算法

#### 分代收集理论

目前大多数的垃圾收集器都遵循分代收集（Generational Collection）的理论进行设计，它是基于以下 2 个假设：

1. 绝大多数的对象都是朝生夕灭
2. 熬过多次收集的对象越难以收集



这两个分代假设奠定许多垃圾收集器的一致的设计原则，在 Java 堆划分出不同的区域之后，GC 可以每次只回收其中一个或者某些部分的区域。所以才有了 **Minor GC，Major GC，Full GC** 这样的回收类型的划分，也是因为这样的划分，才针对不同区域的特性设计不同的垃圾收集算法，因而发展出了：**标记-复制算法，标记-清除算法，标记-整理算法** 等针对性的垃圾收集算法。



Java 虚拟机至少会把堆划分为 2 个区域：

1. 新生代（Young Generation）：每次垃圾收集都会有大量对象被回收，只有少量对象存活，晋升在老年代中，GC 照顾最频繁的区域
2. 老年代（Old Generation）：比较难回收的对象都在老年代，GC 偶尔会照顾的区域



Java 堆的部分收集（Partial GC）：

1. 新生代收集（Minor GC、Young GC）：只对新生代进行垃圾收集，耗时最短，效果最好
2. 老年代收集（Major GC、Old GC）：只对老年代进行收集，目前只有 CMS 会单独收集老年代
3. 混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集，目前只有 G1 收集器会有这种行为
4. 整堆收集（Full GC）：对整个 Java 堆和方法区进行垃圾收集，耗时最长



值得注意的是：分代收集理论也有缺陷，最新（或实验中）的几款 GC 收集器都展现出面向全区域的收集设计思想和工作模式



#### 标记-清除算法

**标记-清除（Mark-Sweep）**算法是 1960 年由 Lisp 之父 John McCarthy 所提出，它的工作原理是：

1. 标出需要回收的对象，在标记完成后，统一回收掉所有被标记的对象
2. 也可以反过来，标记存活的对象，统一回收未被标记的对象



它是后续大多数收集算法的基础，都是针对它的缺点改进，它的缺点如下：

1. 执行效率不稳定：Java 堆数量越大，标记和清除都会随着对象数量增长的导致执行效率的降低
2. 内存空间碎片化：产生大连不连续内存，更从而导致需要分配较大对象时无法找到足够的连续内存，频发的触发 GC 等



标记-清楚算法示意图

<img src="https://pcloud-1258173945.cos.ap-guangzhou.myqcloud.com/uPic/image-20220220095537317.png" alt="image-20220220095537317" style="zoom:33%;" />



#### 标记-复制算法

为了解决标记-清除算法的缺点，1969 年 Fenichel 提出一种  **半区复制"（Semispace Copying）**的垃圾收集算法，它的工作原理是将可用内存按容量分为两块，每次只使用其中一块，当这一块的内存用完，就将还存活的对象复制到另一块上面，然后把已使用过的内存空间一次清理掉。算法的执行示意图：

<img src="https://pcloud-1258173945.cos.ap-guangzhou.myqcloud.com/uPic/image-20220220101246709.png" alt="image-20220220101246709" style="zoom:33%;" />

这种算法的优点是：

1. 如果只有少量对象存活，回收和运行效率高（只适合新生代）
2. 每次都是针对半个区域进行回收，分配内存不用考虑碎片化的问题

缺点是：

1. 如果内存多数对象都是存活的，那么会产生大量的复制开销
2. 这种算法将可用内存缩小到原来的一半，浪费太多空间



HotSpot 采用更优的标记-复制算法：

1. IBM 研究新生代有 98% 的对象熬不过第一轮收集，因为得出结论：不需要按照 1:1 的比例来划分内存空间
2. 把新生代分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次内存分配只使用  Eden 和其中一块 Survivor 空间
3. 发生 GC 时，将 Eden 和 Survivor 仍然存活的对象复制到另一块 Survivor 空间上，然后清理 Eden 和 Survivor 1 空间
4. 为了最大化利用空间，HotSpot 虚拟机默认的 Eden 和 Survivor 比例是 `8:1:1`



#### 标记-整理算法

复制算法的弊端是对象存活率较高的时候，复制效率会降低，而且会浪费内存空间，**所以老年代的对象特征一般不直接选用这种算法**，针对老年代的存亡特征，1974 年 Edward Lueders 提出 **标记-整理（Mark-Compact）** 算法，它的工作过程和 **标记-清除（Mark-Sweep）** 算法一样，只是最后步骤是让所有存活对象都想内存空间一端移动，然后直接清理边界以外的内存，示意图如下：

<img src="https://pcloud-1258173945.cos.ap-guangzhou.myqcloud.com/uPic/image-20220220103831519.png" alt="image-20220220103831519" style="zoom:33%;" />

移动存活对象是一种极为负重的操作，必须全程暂停用户应用才能进行，常见的 STW（Stop The World），所以是否移动对象都会存在弊端，主要如下：

1. 移动对象，不会产生内存连续碎片，分配内存时简单，吞吐量高，但是在回收时更复杂，GC 停顿时间长
2. 不移动，会产生内存连续碎片，在回收时简单，GC 停顿时间短，但是在分配内存的时候更复杂，吞吐量低



在 HotSpot 虚拟机里面关注吞吐量的 Parallel Scavenge 收集器是基于标记-整理算法，而关注低延迟的 CMS 收集器则是基于标记-清楚算法的，也从侧面印证了以上两点



### HotSop 的算法细节

作者用心良苦之言：

>  如果读者对这部分感到枯燥。。。或者疑惑，不妨先跳过去，等后续遇到使用它们的场景，实际问题再结合问题，重新翻阅和理解。。。



有点自知之明的我，我就先跳过了。。



#### 根节点枚举

可达性分析 GC Roots 是从根节点枚举开始，根节点枚举始终还是必须在一个能保障一致性的快照中才得以进行，系统看起来像被冻结在某个时间点上，不会出现分析过程中，根节点集合的对象引用关系还在不断变化的情况，若不能满足这点的话，那么 GC Roots 分析结果的准确性也无法保证，就像你在打扫房间必须要先把门关起来，如果你一边搞卫生，一边有人在扔垃圾，那么房间就永远无法打扫干净。所以根节点枚举和之前的整理内存碎片一样会面临 Stop The World 的困扰



这就是导致 GC 必须停顿所有线程的原因，**即使是号称停顿时间可控或者几乎不会停顿的 CMS、G1、ZGC 等收集器，枚举根节点也是必须要停顿的**。



#### 安全点

HotSpot 只有在特定的位置才会记录 OopMap 信息，这些位置成为安全点 SafePoint，程序必须执行到达安全点后才能暂停，然后再开始垃圾回收 ♻️。



关于安全点，还有一个问题就是如何在 GC 发生的时候让所有线程都跑到安全点，这里有两种方案：

1. 抢先时中断（Preemptive Suspension）：系统把用户线程全部中断，几乎没有虚拟机采用该方案
2. 主动式中断（Voluntary Suspension）：设置一个标记位，线程主动去轮询标记，当标记中断时候线程主动挂起