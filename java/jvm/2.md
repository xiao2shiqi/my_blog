## Java 内存区域和内存溢出

### 运行时数据区域

Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域，各自区域有各自的用途，JVM 内存区域总览（如图）：

<img src="https://pcloud-1258173945.cos.ap-guangzhou.myqcloud.com/uPic/D08bIm.png" alt="D08bIm" style="zoom:33%;" />

下面会讲解虚拟机各个区域的具体职责和功能划分



#### 程序计数器

程序计数器（Program Counter Register）是一块较小的内存空间

程序计数器的作用：

* 线程所执行的字节码的行号指示器
* 为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器
* 程序计数器占用的内存是线程私有的内存



#### 虚拟机栈 VM Stack

* 虚拟机栈描述的是 Java 方法执行的线程内存模型
* 每个方法被执行的时候虚拟机都会同步创建一个栈帧，保存局部变量表，操作数栈，动态链接等信息



虚拟机中常见两种内存区域异常有一个就来源于此，具体是：

* 线程请求的栈深度（方法调用）大于虚拟机所允许的深度，就会抛出 StackOverFlowError 异常
* 虚拟机内存容量可以动态扩容，当虚拟机无法申请到足够的内存就会抛出 OutOfMemoryError 异常



#### 本地方法栈

本地方法栈（Native Method Stack）类似 VM Stack（虚拟机栈），不同的是 VM Stack 服务对象是虚拟机执行的 Java 方法，而本地方法栈则是为虚拟机使用的本地方法（Native Method ）提供服务。

因为本地方法（Native Method）日常使用非常少，大多数的 Native Method 都是 Unsafe 操作，所以大概了解就好了。

另外需要注意的是本地方法栈区域同样会因为内存不足而抛出 StackOverFlowError 和 OutOfMemoryError 异常



####  堆空间 Heap

Java 堆空间的特点：

1. 堆空间 Heap 虚拟机所管理的最大的一块内存区域，被所有线程共享使用
2. Java 世界里面几乎所有的对象实例都在这里分配内存
3. Java GC 垃圾收集器重点关照的内存区域，所以堆是基于分代理论设计的，**但目前很多虚拟机已经不采用分代的设计了**
4. 堆空间的分代设计，还是细分的目的都是为了更好，更快的回收内存
5. 堆空间可以通过（-Xmx 和 -Xms 设定固定大小），但默认的实现是可扩展的，并且当堆空间无法再扩展内存的时候，虚拟机就会抛出 OutOfMemoryError 异常



新生代（一个 Eden 和两个 Survivor 区域）、老年代这种划分，历史上有许多款虚拟机采用这种设计，包括 HotSpot 和它的前身 Self、StrongTalk 虚拟机，源自 UC Berkeley 在 20 世纪 80 年代中期开发的 Berkeley Smalltalk



#### 方法区

方法区 Method Area 区域的特点：

1. 主要用于存储被虚拟机加载的类型信息，常量，静态变量，即时编译器编译后的代码缓存等数据
2. 跟堆 Heap 空间一样，是各个线程共享的内存区域



经常有人会把方法区和永久代混淆，两者完全是不同的概念，这里有必要解释一下：

永久代更容易导致内存溢出的问题，例如 String::intern()，所以JDK 8 完全废弃永久代的概念，在本地内存中实现元空间（Meta-Space）来代替。



方法区内部的运行时常量池的作用

* 用于存放编译期生成的各种字面量于符号引用
* 开发人员经常利用 String 类的 intern() 方法在运行时常量池缓存字符
* 当常量池无法再申请内存时会抛出 OutOfMemoryError 异常



#### 直接内存

Direct Memory 不属于虚拟机的一部分，但是如果频繁使用也会出现 OutOfMemoryError 异常，Direct Memory 的常见场景是在 JDK 1.4 中心加入的 NIO 类，它可以使用  Native 函数库直接分配堆外内存。



Direct Memory 的优缺点：

优点：直接分配内存不受 Java 堆大小的限制

缺点：容易被忽略，导致动态扩展的时候出现 OOM 异常



###  HotSpot 对象揭秘

#### 对象的创建过程

在语言层面创建对象仅仅是一个 `new` 关键字而已，但是在虚拟机中对象入如何创建的呢？

虚拟机创建对象的五个步骤：

1. 虚拟机遇到 `new` 指令的时候，首先会检查类的加载，解析和初始化情况（我们假设类已经被加载，后续再探讨类的加载过程）
2.  然后就是为对象在 Java 堆中分配内存，虚拟机必须将分配到内存空间的对象初始化为零值（如果使用 TLAB 的话，这一项工作也可以提前至 TLAB 分配时顺便进行）
2.  为对象进行必要的设置，例如：类的实例，哈希码，对象的 GC 分代年龄等，这些信息存在对象的 Object Header 中
2.  虚拟机构建新的对象后，Class 文件中的 `init()` 方法还没执行，所有字段都是零值
2.  new 指令之后会借着执行  `init()` 方法，按照程序员的意愿进行对象初始化，真正的对象此时才算被构造出来



#### 对象的内存布局

在 HotSpot 虚拟机内，对象的布局为三部分：

- 对象头 Header （对象头包括两类信息）
  - 存储对象自身的运行时数据：哈希吗 HashCode，GC 分代年龄，锁状态标志，线程持有的锁，偏向线程 ID，偏向时间戳等
  - 类型指针：类型的元数据指针，Java 虚拟机通过这个指针来确定对象类的实例

- 实例数据 Instance Data：对象真正有效的信息，程序代码中所定义各种类型的字段内容

- 对齐填充 Padding：HotsSpot 要求任何对象的大小都必须是 8 字节的整数倍，所以实例数据没有对齐的话，就需要通过对齐填充来补全





#### 对象的访问

创建对象的目的自然是为了访问和使用，主流的访问方式主要有使用句柄和直接指针两种：

第一种：使用句柄（极少使用，不推荐）

在堆中划分内存作为句柄池，栈中存储句柄地址，句柄池中存储对象的具体地址

优点：reference 存储地址问稳定，就算对象移动，只会修改句柄指针，reference 无需修改

缺点：性能差

如图：

<img src="https://pcloud-1258173945.cos.ap-guangzhou.myqcloud.com/uPic/image-20220219154806153.png" alt="image-20220219154806153" style="zoom:33%;" />

第二种：直接指针（常用）

直接在 reference 中存储对象地址，可以直接访问对象，不需要多一次间接访问的开销，因为在 Java 中对象的访问极其的频繁，因此这类开销也是一项极其客观的执行成本

<img src="https://pcloud-1258173945.cos.ap-guangzhou.myqcloud.com/uPic/image-20220219155203617.png" alt="image-20220219155203617" style="zoom:33%;" />

### OOM 最佳实践

实践 OOM 的两个目的：

* 验证 Java 虚拟机描述各个区域的存储内容
* 遇到内存溢出时候，可以迅速的得知是哪个区域的溢出问题



#### Java 堆溢出

Java 堆内存的 OOM 应该是实际应用中最常见的内存异常情况，触发堆 OOM 的前置条件是：

1. 不停的创建对象
2. 保证 GC Roots 到对象之间有可达路径来摆满垃圾回收
3. 对着对象数量的触发，就会产生内存溢出



一段可以触发 OOM 的代码：

VM 参数：`VM Args: -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/Users/xiaobin/Downloads/java_heapdump.hprof`

```java
public class HeapOOM {

    static class OOMObject {
    }

    public static void main(String[] args) {
        List<OOMObject> list = new ArrayList<>();
        while (true) {
            list.add(new OOMObject());
        }
    }
}
```

运行结果：

```sh
java.lang.OutOfMemoryError: Java heap space
Dumping heap to /Users/xiaobin/Downloads/java_heapdump.hprof ...
Heap dump file created [29193688 bytes in 0.131 secs]
Exception in thread "main" java.lang.OutOfMemoryError: Java heap space
```



提供两个解决堆 OOM 的思路：

1. 如果是内存泄漏，使用 MAT 查看对象到 GC Roots 的引用链，找到对象无法被 GC 回收的原因，从而定位问题
2. 如果是内存不足，检查虚拟机的堆参数（-Xmx 与 - Xms）设置和机器内存对比，上调代码。再检查代码，减少设计不合理的情况



#### 虚拟机栈溢出

栈溢出的第一种情况：

线程请求的栈深度大于虚拟机所允许的最大深度，会抛出 StackOverflowError 异常，如下：

```java
public class JavaVMStackSOF {

    private int stackLength = 1;

    public void stackLeak() {
        stackLength++;
        stackLeak();
    }

    public static void main(String[] args) throws Throwable {
        JavaVMStackSOF oom = new JavaVMStackSOF();
        try {
            // 不停的调用自己，直到产生 StackOverFlowError
            oom.stackLeak();
        } catch (Throwable e) {
            System.out.println("stack length:" + oom.stackLength);
            throw e;
        }
    }
}
```

输出结果：

```sh
stack length:498
Exception in thread "main" java.lang.StackOverflowError
	at JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:10)
```

结论：当新的栈帧内存无法分配的时候，HotSpot 虚拟机抛出的都是 StackOverflowError 异常。如果使用 HotSpot 虚拟机默认参数，栈深度在大多数情况下达到 1000~2000 是没问题的，对于正常的方法调用是完全够用的。



栈溢出的第二种情况：

创建线程导致内存溢出：VM 参数：`-Xss2M`

```java
public class JavaVMStackOOM {

    private void dontStop() {
        while(true) {
        }
    }

    public void stackLeakByThread() {
        while (true) {
            Thread thread = new Thread(() -> dontStop());
            thread.start();
        }
    }

    public static void main(String[] args) {
        JavaVMStackOOM oom = new JavaVMStackOOM();
        oom.stackLeakByThread();
    }
}
```

执行结果：

```sh
Exception in thread "main" java.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached
	at java.base/java.lang.Thread.start0(Native Method)
	at java.base/java.lang.Thread.start(Thread.java:803)
```



#### 方法区和运行时常量池溢出

运行时常量池溢出主要原因：

JDK 7 以前主要是 `String::intern()` 会将对象添加到常量池中，如果处理不当容易出现 OOM。但是 JDK 7 开始逐步去永久代的计划，并在 JDK 8 中使用元空间来代替。所以 JDK 7 及以上的版本大多不需要担心该问题。



方法区溢出的主要原因：

方法区主要是存放类型的信息，类名，访问修饰符，常量池，字段描述，方法描述等。目前很多主流框架，例如 Spring，Hibernate 对类进行增强时，都会使用 CGLib 这类字节码结束，当增强的类越多，就需要越大的方法区保证动态生成的类型可以载入内存。



#### 本机直接内存溢出

直接内存使用 `-XX:MaxDirectMemorySize` 参数设置，默认与 Java 堆最大值相同 `-Xmx 指定`，以下代码是通过 **Unsafe** 类操作堆外内存，最终导致直接内存溢出，代码如下:

```java
public class DirectMemoryOOM {

    public static final int _1MB = 1024 * 1024;

    public static void main(String[] args) throws Exception {
        Field unsafeField = Unsafe.class.getDeclaredFields()[0];
        unsafeField.setAccessible(true);
        Unsafe unsafe = (Unsafe) unsafeField.get(null);
        while (true) {
            unsafe.allocateMemory(_1MB);
        }
    }
}
```

程序有以下几个特征，就可以重点检查直接内存了：

* Heap Dump 文件中没有明显异常情况，或者 Dump 文件很小
* 程序中直接或间接的使用了 DirectMemory（间接使用 NIO）

---

## 垃圾收集器和内存分配





