## 类文件结构

计算机只认识 1 和 0 ，那为什么还会有字节码的存在 ？

1. 用户编写的代码被 `javac` 翻译为统一的字节码 `class` 文件
2. 不同版本的 JVM 将字节码 `class` 文件根据不同的平台，翻译为 1 和 0 的机器码文件，**从而实现跨平台**

答案：**因为字节码是和机器指令集，系统平台无关的存储格式**，所以通过不同平台的虚拟机来执行字节码，从而保证程序执行有相同的结果。



平台无关性的基石：

1. Java 刚诞生的著名口号：Write Once，Run Anywhere 就是通过 JVM 虚拟机来实现的
2. 虚拟机不仅支持 Java，目前运行在 JVM 的语言有：Kotlin，Groovy，JRuby，Scala  等
3. JVM 实现语言和平台无关性的基石就是：虚拟机和字节码的存储格式
4. 只要能把源代码编译微 Class 文件，虚拟机丝毫不关心 Class 的来源是什么语言
5. 字节码指令提供的语言描述能力比 Java 语言本身更加强大，也让其他语言有更大的发挥空间



虚拟机执行程序的过程，如图：

<img src="https://pcloud-1258173945.cos.ap-guangzhou.myqcloud.com/uPic/image-20220303143226678.png" alt="image-20220303143226678" style="zoom:33%;" />



### Class 文件结构

关键信息：

1. 类文件格式的学习过程会非常枯燥，但是要深入虚拟机，这部分是无法回避的
2. Java 技术能保持良好的向后兼容，稳定的 Class 文件结构发挥了关键作用
3. 1997 年定义的 Class 文件结构至今只是新增、扩充内容，并且对已定义的内容做出修改



#### 魔数和 Class 文件的版本

关于魔数：

1. Class 文件的头 4 个字节被称为魔数（Magic Number），作用是确认是否能被虚拟机接受的 Class 的文件
2. 许多文件格式都是用魔数来进行身份标识，相比文件扩展名更安全而且可以自由的选择魔数值
3. Class 文件的魔数值为 0xCAFEBABE，出自早期小组成员喜欢的咖啡品牌，也象征以后 Java 的出现



关于版本号：

1. 魔数后的 4 个字节存储是 Class 文件的版本号
2. 5、6 号字节是次版本号，7、8 号字节是主版本号
3. 高版本 JDK 可以向下兼容执行低版本的 Class 文件，但是不能运行以后版本的 Class 文件
4. 虚拟机拒绝执行超过其版本号的 Class 文件



Class 的文件结构如图：

<img src="https://pcloud-1258173945.cos.ap-guangzhou.myqcloud.com/uPic/image-20220303154257798.png" alt="image-20220303154257798" style="zoom: 50%;" />



#### 常量池

1. 主、次版本号之后就是常量池入口，通常数量不固定，所以在入口放置 u2 类型数据代表常量池容器计数值
2. 常量池容量为 22 就代表池中有 21 项常量，常量池比较特殊计数是从 1 开始的
3. 常量池中存放两大类常量：字面量 Literal、符号饮用 Symbolic References。接近 Java 语言的常量概念
4. 最初有 11 种结构，为了更好支持动态语言增加 4 种常量，为了支持 Java 11 模块化又增加 2 种常量
4. JDK 的 bin 目录提供专门用于分析 Class 文件字节码的工具：`javap` ，使用方法参考下文



索引范围 1～22 的常量池结构：

<img src="https://pcloud-1258173945.cos.ap-guangzhou.myqcloud.com/uPic/image-20220303161520158.png" alt="image-20220303161520158" style="zoom:33%;" />



javap 命令的简单用法，如下：

```sh
$ javap -verbose JConsoleDemo.class
Classfile /Users/xiaobin/Documents/IdeaWorkSpace/JVM_Demo/out/production/JVM_Demo/JConsoleDemo.class
  Last modified Mar 1, 2022; size 1055 bytes
  MD5 checksum 45e2200aef376ca4591855cca074eeb2
  Compiled from "JConsoleDemo.java"
public class JConsoleDemo
  minor version: 0
  major version: 52
  flags: (0x0021) ACC_PUBLIC, ACC_SUPER
  this_class: #12                         // JConsoleDemo
  super_class: #13                        // java/lang/Object
  interfaces: 0, fields: 0, methods: 3, attributes: 2
Constant pool:
# ..... 这里省略
```



#### 访问标志

1. 接着常量池后面的 2 个字节代表访问标志 access_flags，识别类、接口的访问信息
2. 包含信息：类、抽象类和接口的信息，访问权限的信息，还有 final 等等信息



访问标志符号的含义如下：

<img src="https://pcloud-1258173945.cos.ap-guangzhou.myqcloud.com/uPic/image-20220303164158482.png" alt="image-20220303164158482" style="zoom: 50%;" />

access_flags 在 Class 文件中的显示，如下：

<img src="https://pcloud-1258173945.cos.ap-guangzhou.myqcloud.com/uPic/image-20220303164307731.png" alt="image-20220303164307731" style="zoom: 50%;" />



#### 类索引和接口索引

1. Class 的继承关系由：类索引 this_class，父类索引 super_class，接口索引集合 interfaces 这三项数据来确定
2. Java 语言不允许多继承，除了 java.lang.Object 以外，父类索引只有一个，且父类索引都不为 0
3. 接口索引集合描述类实现了哪些接口，接口按照 implements 从左到右的顺序排列



#### 字段表集合

1. 字段表 field_info 用于描述类中声明的变量，但不包括方法内部的局部变量
2. 字段中的修饰符很适合用布尔值来表示，很像类中的 access_flags 项目
3. access_flags 标志紧接的是 name_index、descriptor_index 它们分别代表字段简单名称、字段和方法的描述



字段访问标志：

<img src="https://pcloud-1258173945.cos.ap-guangzhou.myqcloud.com/uPic/image-20220303171420753.png" alt="image-20220303171420753" style="zoom:50%;" />

字段表的结构实例：

<img src="https://pcloud-1258173945.cos.ap-guangzhou.myqcloud.com/uPic/image-20220303171944255.png" alt="image-20220303171944255" style="zoom:50%;" />



#### 方法表集合

1. Class 文件对方法的描述和对字段的描述几乎完全一致，也包含 access_flags，name_index，descriptor_index、attributes 几项
2. 方法里的代码经过 `javac` 编译成字节码指令，存放在 `Code` 属性里面，属性是 Class 文件最具扩展性的一种数据项目
3. 如果父类方法没有在子类被重写，方法表集合中就不会出现来自父类的方法信息



方法表的结构实例：

<img src="https://pcloud-1258173945.cos.ap-guangzhou.myqcloud.com/uPic/image-20220303173441502.png" alt="image-20220303173441502" style="zoom:50%;" />



#### 属性表集合

1. Class 文件、字段表、方法表都可以携带自己的属性表集合，描述场景的专有信息
2. 与 Class 的严格要求不同，属性表集合的限制稍微宽松一些，虚拟机会忽略掉它不认识的属性
3. Code 属性是 Class 文件最重要的部分，Java 程序可以简单的分为两部分：代码 Code、元数据
4. 了解 Code 属性是学习字节码执行引擎内容的必要基础，能够阅读字节码也是基本技能



Code 属性结构实例：

<img src="https://pcloud-1258173945.cos.ap-guangzhou.myqcloud.com/uPic/image-20220303180825635.png" alt="image-20220303180825635" style="zoom:50%;" />



### 字节码指令简介

🌟 简介完全看不懂，这里就跳过去了。。

🌟 小章节也基本看不懂，先速读好了，大概记录一下，等想深究的时候再回来看看



#### 字节码与数据类型

1. 阅读字节码是了解 Java 虚拟机的基本技能，是一项应当熟练掌握的能力
2. 如果希望了解更详细的信息，可以阅读由 Oracle 官方授权的，周志明翻译的《Java 虚拟机规范（Java SE 7）》中文版



#### 同步指令

1. 同步指令集序列由 `synchronized` 语句来表示，在虚拟机中有 `monitorenter`、`monitorexit` 指令来支持
2. 方法中调用过的每条 `monitorenter` 都必须有其对应的 `monitorexit` 指令



来看一段编译后的同步代码：

<img src="https://pcloud-1258173945.cos.ap-guangzhou.myqcloud.com/uPic/image-20220303213843479.png" alt="image-20220303213843479" style="zoom:50%;" />



#### Class 结构的发展

1. Class 文件结构发布超过二十年，这二十多年 Java 技术体系有翻天覆地的变化，但是 Class 文件结构一直比较稳定，几乎没有更变
2. 仅仅在文件格式的改进，标志，属性表这些设计上扩展新内容而已
3. Class 文件格式的扩展，大部分用于支持 Java 中许多语言特性，例如枚举，变长参数，泛型，动态注解等等
4. Class 文件具备的平台中立，紧凑，稳定和可扩展性的特点，是 Java 技术体系的重要支柱



## 虚拟机的类加载机制

1. Class 文件的所有信息最终都会被加载到虚拟机才能被运行和使用
2. Java 里面类型加载、连接和初始化都是在程序运行期间完成的，这种策略让 Java 牺牲了提前编译的能力和增加类加载的开销，但是为 Java 应用提供了扩展性和灵活性，例如 AOP，IOC，反射等特性都依赖动态加载的能力实现的



### 类加载的时机

类加载的七个阶段，也称类的生命周期，如图：

<img src="https://pcloud-1258173945.cos.ap-guangzhou.myqcloud.com/uPic/image-20220303215449319.png" alt="image-20220303215449319" style="zoom:50%;" />



加载阶段：在《Java 虚拟机规范》中没有强制约束，由虚拟机的实现自由把握

初始化阶段：《Java 虚拟机规范》严格规定以下六种情况必须对类进行初始化：

1. 遇到 new、getstatic、putstatic、invokestatis 这四条指令的时候
2. 使用 java.lang.reflect 的方法对类型进行反射的时候
3. 初始化类的时候，先触发父类的初始化
4. 虚拟机启动的时候，会先去初始化主类
5. 关于 JDK 7 新加入的动态语言支持。。等
6. JDK 8 接口中定义的默认方法时，初始化该接口



要点：

1. 对于静态字段只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化



### 类的加载过程

#### 第一步：加载

加载 Loading 的三个过程：

1. 通过类的全限定名来获取定义此类的二进制字节流
2. 将字节流的静态存储结构转化为方法区的运行时数据结构
3. 在内存中生成 java.lang.Class 对象



虚拟机并没有限定从哪里获取二进制字节流，给充满创造力的开发者许多发挥空间，例如：

1. 从 zip 包中读取字节流，这是 JAR，WAR 格式的基础
2. 从网络中获取，典型场景是 Web Applet 的应用
3. 运行时计算生成，这是动态代理技术的基础，典型应用就是 java.lang.reflect.Proxy
4. …………



#### 第二步：验证

为什么要验证 ？

1. 验证阶段的目的是确保 Class 文件信息《Java 虚拟机规范》符合规范和安全
2. 任何危险的操作都会被编译器无情的抛出异常，拒绝编译。这是 Java 安全编程的基础
3. Java 虚拟机如果不检查输入的字节流，对其完全信任的话，很可能会因为载入了有错误或有恶意企图的字节码流而导致整个系统受攻击甚至崩溃



验证大致的四个阶段动作：

1. 文件格式验证：验证格式规范，包括：魔数、版本号、常量池、等等……
2. 元数据验证：验证语义分析，包括：父类，集成，抽象，字段，等等…………
3. 字节码验证：验证程序语义和逻辑，包括：Code 属性，指针跳转检查，方法体的内容，等等…… 
4. 符号引用验证：符号引用的有效性，指定类的规范，字段、方法的可访问性



总结：

1. 验证阶段非常重要，但不是必须要执行的阶段。
2. 如果程序已经被反复验证过（例如 Eclipse）安全性，可以考虑使用 `-Xverify:none` 关闭类的验证措施，来缩短虚拟机加载时间



#### 第三步：准备

准备阶段是正式为类中定义的变量，分配内存并设置类变量初始值的阶段，分配特点如下：

1. JDK 以前类变量都在内存的方法区中分配，JDK 8 以后类变量随着 Class 对象存放在 Java 堆中
2. 类变量不是实例变量，实例变量会在对象实例化时随着对象一起分配在 Java 堆中
3. 类变量在准备阶段会赋予**零值**，而**变量的初始值是在初始化阶段赋值的**，这两个概念要搞清楚

基本数据类型的零值：

<img src="https://pcloud-1258173945.cos.ap-guangzhou.myqcloud.com/uPic/image-20220308134802966.png" alt="image-20220308134802966" style="zoom:50%;" />

如果类字段属性表中存在 `final` 属性，那么在准备阶段就会被初始化，如下：

```java
public static final int value = 123;
```

在准备阶段虚拟机就会把 value 复制为 123



#### 第四步：解析

解析阶段是 Java 虚拟机将常量池内的符号引用替换为直接引用的过程：

* 符号引用：以一组符号来描述所引用的目标，可以是任何形式的字面量，只要能定位到目标即可，各种虚拟机实现的内存布局可以各不相同，但是他们接受的符号引用必须是一致的。
* 直接引用：可以直接指向目标指针，是一个能简介定位到目标的句柄，有了直接引用，那引用的目标必定已经在虚拟机内存中存在



#### 第五步：初始化

类的初始化阶段是类接在过程的最后一个步骤，它的特点如下：

1. 直到初始化阶段，Java 虚拟机才真正开始执行类中编写的 Java 程序代码，将主导权移交给应用程序
2. 准备阶段，变量已经赋过一次零值，初始化阶段则会根据程序编码去初始化变量和其他资源
3. 初始化阶段就是执行类构造器 `<clinit>()` 方法的过程，它是 Javac 编译器的自动生成物



### 类加载器

类加载器最初为满足 Java Applet 的需求而设计，但今天 Applet 基本已经被淘汰，但类加载器却在类层次划分，OSGI，热部署，代码加密等领域大放异彩，成为 Java 技术体系的重要基石。



#### 类与类加载器

1. 类加载器只用于实现类的加载动作，但它的作用却远超类加载阶段
2. 任意一个雷，都必须由加载它的类加载器和类本身来确定其在 Java 虚拟机中的唯一性
3. 两个类是否相等，只有在两个类是同一个类加载器加载的前提下才有意义
4. 所指的相同，代表 `equals()` 方法，`isAssignableForm()` 方法，`isInstance()` 方法



#### 双亲委派模型

在虚拟机的角度类加载器只分两种：

1. Bootstarp ClassLoader 启动类加载器，使用 C++ 语言实现，是虚拟机的一部分
2. 其他类加载器，继承自 java.lang.ClassLoader，由 Java 语言实现，独立于虚拟机外部实现



站在开发者的角度，Java 一直保持三层类加载器，双亲委派模型加载的架构，分别是：

**启动类加载器 Bootstrap ClassLoader：**

1. 加载存放在 `\bin` 目录，而且是能被虚拟机识别的（例如 `rt.jar, tools.jar`，）类库加载到内存中
2. 加载被 `-Xbootclasspath` 参数指定的路径中存放，符合虚拟机要求的文件
3. 如果名字不符合虚拟机要求，及时在指定目录页不会被加载到虚拟机的内存中
4. 启动类加载器无法被 Java 程序直接引用



**扩展类加载器 Extension Class Loader：**

1. ExtClassLoader 负责加载 `\bin\ext` 目录的类库
2. 它是 Java 系统类库的扩展机制，JDK 允许用户通过 `/ext` 目录扩展 Java SE 的功能



**应用程序类加载器 Application Class Loader：**

1. AppClassLoader 负责加载用户类 ClassPath 上所有的类库，开发者可以直接使用
2. 如果没有自定义类加载器，一般情况这就是程序的默认类加载器



<img src="https://pcloud-1258173945.cos.ap-guangzhou.myqcloud.com/uPic/image-20220308143931239.png" alt="image-20220308143931239" style="zoom: 33%;" />



**类加载的双亲委派模型：**

1. JDK 9 之前的 Java 都是由以上三个基本类加载器相互配合来完成加载，如有必要，用户还可以自行扩展，如上
2. 类加载的层次关系成为 **双亲委派模型 Parents Delegation Model** ，该模型要求除启动类加载器外，其余都有自己的父类加载器



**双亲委派模型的工作过程：**

1. 类加载器收到类加载的请求，首先会委托父类加载器去完成加载，每一层都是如此
2. 因此所有请求都会传递到顶层的启动类加载器中
3. 当父类加载器反馈自己无法完成加载请求时，子加载器才会尝试自己去完成加载



**双亲委派模型的好处：**

1. 类只会被加载一次，并且只会被它所负责的类加载器负责加载，从而保证是同一个类
2. 例如存放在 `rt.jar` 中的 `java.lang.Object` 类，无论被谁加载，最终都会传递给启动类加载器进行加载
3. 就算用户自己编写与 `rt.jar` 相同的 `java.lang.Object` 类，也用于无法被启动类加载器加载
4. 保证程序类的结构和层次，保证 Java 类型体系最基础的行为，也保证了程序的稳定运作



双亲委派模型实现异常简单，代码只有 10 余行，全部集中在 `java.lang.ClassLoader` 的 `loadClass()` 方法中，代码如下：

<img src="https://pcloud-1258173945.cos.ap-guangzhou.myqcloud.com/uPic/image-20220308145353439.png" alt="image-20220308145353439" style="zoom: 50%;" /> 



### 本章小结

1. 介绍了类加载的 5 个过程，还有类加载的工作原理和对虚拟机的意义
2. 掌握了 Class 文件中定义类，以及如何将类加载到虚拟机之中的两个知识点
3. 下一章看看虚拟机如何执行 Class 文件中的字节码



## 虚拟机字节码执行引擎

都是指令层面的，等巩固基础再来看吧。

基本看不懂。。。TODO 。跳过吧。。。需要的时候再回来



目录大纲

1. 运行时栈帧结构
2. 方法调用
3. 动态类型语言支持
4. 基础栈的字节码解释执行引擎



本章小结：

分析虚拟机在执行代码的时候，做的如下事情：

1. 如何找到正确的方法
2. 如何执行方法内的字节码
3. 执行代码时涉及的内存结构
4. 6~8 章主要针对 Java 存储，载入，执行的问题介绍
5. 下面会介绍以上的理论知识在实践中如何应用



## 类加载及执行子系统的实战



都是指令层面的，等巩固基础再来看吧。

基本看不懂。。。TODO 。跳过吧。。。需要的时候再回来



本章主要介绍：

1. Tomcat：正统的类加载器架构
2. OSGI：灵活的类加载器架构
3. **字节码生成技术与动态代码的实现（感觉还蛮实用）**
4. Backport 工具：Java 的时光机（使用高版本的 JDK 语法，运行在低版本的 Java 环境下的工具）
5. 自己手动实现远程执行功能（类似阿里巴巴的 Arthas 等工具，给运行时的环境注入代码进行调试）



本章小结：

1. 介绍 Class 文件格式，类加载及虚拟机执行引擎
2. 了解虚拟机如何执行，才能更好的理解怎样写出优秀的代码
3. 