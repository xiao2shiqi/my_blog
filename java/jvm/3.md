## 类文件结构

计算机只认识 1 和 0 ，那为什么还会有字节码的存在 ？

1. 用户编写的代码被 `javac` 翻译为统一的字节码 `class` 文件
2. 不同版本的 JVM 将字节码 `class` 文件根据不同的平台，翻译为 1 和 0 的机器码文件，**从而实现跨平台**

答案：**因为字节码是和机器指令集，系统平台无关的存储格式**，所以通过不同平台的虚拟机来执行字节码，从而保证程序执行有相同的结果。



平台无关性的基石：

1. Java 刚诞生的著名口号：Write Once，Run Anywhere 就是通过 JVM 虚拟机来实现的
2. 虚拟机不仅支持 Java，目前运行在 JVM 的语言有：Kotlin，Groovy，JRuby，Scala  等
3. JVM 实现语言和平台无关性的基石就是：虚拟机和字节码的存储格式
4. 只要能把源代码编译微 Class 文件，虚拟机丝毫不关心 Class 的来源是什么语言
5. 字节码指令提供的语言描述能力比 Java 语言本身更加强大，也让其他语言有更大的发挥空间



虚拟机执行程序的过程，如图：

<img src="https://pcloud-1258173945.cos.ap-guangzhou.myqcloud.com/uPic/image-20220303143226678.png" alt="image-20220303143226678" style="zoom:33%;" />



### Class 文件结构

关键信息：

1. 类文件格式的学习过程会非常枯燥，但是要深入虚拟机，这部分是无法回避的
2. Java 技术能保持良好的向后兼容，稳定的 Class 文件结构发挥了关键作用
3. 1997 年定义的 Class 文件结构至今只是新增、扩充内容，并且对已定义的内容做出修改



#### 魔数和 Class 文件的版本

关于魔数：

1. Class 文件的头 4 个字节被称为魔数（Magic Number），作用是确认是否能被虚拟机接受的 Class 的文件
2. 许多文件格式都是用魔数来进行身份标识，相比文件扩展名更安全而且可以自由的选择魔数值
3. Class 文件的魔数值为 0xCAFEBABE，出自早期小组成员喜欢的咖啡品牌，也象征以后 Java 的出现



关于版本号：

1. 魔数后的 4 个字节存储是 Class 文件的版本号
2. 5、6 号字节是次版本号，7、8 号字节是主版本号
3. 高版本 JDK 可以向下兼容执行低版本的 Class 文件，但是不能运行以后版本的 Class 文件
4. 虚拟机拒绝执行超过其版本号的 Class 文件



Class 的文件结构如图：

<img src="https://pcloud-1258173945.cos.ap-guangzhou.myqcloud.com/uPic/image-20220303154257798.png" alt="image-20220303154257798" style="zoom: 50%;" />



#### 常量池

1. 主、次版本号之后就是常量池入口，通常数量不固定，所以在入口放置 u2 类型数据代表常量池容器计数值
2. 常量池容量为 22 就代表池中有 21 项常量，常量池比较特殊计数是从 1 开始的
3. 常量池中存放两大类常量：字面量 Literal、符号饮用 Symbolic References。接近 Java 语言的常量概念
4. 最初有 11 种结构，为了更好支持动态语言增加 4 种常量，为了支持 Java 11 模块化又增加 2 种常量
4. JDK 的 bin 目录提供专门用于分析 Class 文件字节码的工具：`javap` ，使用方法参考下文



索引范围 1～22 的常量池结构：

<img src="https://pcloud-1258173945.cos.ap-guangzhou.myqcloud.com/uPic/image-20220303161520158.png" alt="image-20220303161520158" style="zoom:33%;" />



javap 命令的简单用法，如下：

```sh
$ javap -verbose JConsoleDemo.class
Classfile /Users/xiaobin/Documents/IdeaWorkSpace/JVM_Demo/out/production/JVM_Demo/JConsoleDemo.class
  Last modified Mar 1, 2022; size 1055 bytes
  MD5 checksum 45e2200aef376ca4591855cca074eeb2
  Compiled from "JConsoleDemo.java"
public class JConsoleDemo
  minor version: 0
  major version: 52
  flags: (0x0021) ACC_PUBLIC, ACC_SUPER
  this_class: #12                         // JConsoleDemo
  super_class: #13                        // java/lang/Object
  interfaces: 0, fields: 0, methods: 3, attributes: 2
Constant pool:
# ..... 这里省略
```



#### 访问标志

1. 接着常量池后面的 2 个字节代表访问标志 access_flags，识别类、接口的访问信息
2. 包含信息：类、抽象类和接口的信息，访问权限的信息，还有 final 等等信息



访问标志符号的含义如下：

<img src="https://pcloud-1258173945.cos.ap-guangzhou.myqcloud.com/uPic/image-20220303164158482.png" alt="image-20220303164158482" style="zoom: 50%;" />

access_flags 在 Class 文件中的显示，如下：

<img src="https://pcloud-1258173945.cos.ap-guangzhou.myqcloud.com/uPic/image-20220303164307731.png" alt="image-20220303164307731" style="zoom: 50%;" />



#### 类索引和接口索引

1. Class 的继承关系由：类索引 this_class，父类索引 super_class，接口索引集合 interfaces 这三项数据来确定
2. Java 语言不允许多继承，除了 java.lang.Object 以外，父类索引只有一个，且父类索引都不为 0
3. 接口索引集合描述类实现了哪些接口，接口按照 implements 从左到右的顺序排列



#### 字段表集合

1. 字段表 field_info 用于描述类中声明的变量，但不包括方法内部的局部变量
2. 字段中的修饰符很适合用布尔值来表示，很像类中的 access_flags 项目
3. access_flags 标志紧接的是 name_index、descriptor_index 它们分别代表字段简单名称、字段和方法的描述



字段访问标志：

<img src="https://pcloud-1258173945.cos.ap-guangzhou.myqcloud.com/uPic/image-20220303171420753.png" alt="image-20220303171420753" style="zoom:50%;" />

字段表的结构实例：

<img src="https://pcloud-1258173945.cos.ap-guangzhou.myqcloud.com/uPic/image-20220303171944255.png" alt="image-20220303171944255" style="zoom:50%;" />



#### 方法表集合

1. Class 文件对方法的描述和对字段的描述几乎完全一致，也包含 access_flags，name_index，descriptor_index、attributes 几项
2. 方法里的代码经过 `javac` 编译成字节码指令，存放在 `Code` 属性里面，属性是 Class 文件最具扩展性的一种数据项目
3. 如果父类方法没有在子类被重写，方法表集合中就不会出现来自父类的方法信息



方法表的结构实例：

<img src="https://pcloud-1258173945.cos.ap-guangzhou.myqcloud.com/uPic/image-20220303173441502.png" alt="image-20220303173441502" style="zoom:50%;" />



#### 属性表集合

1. Class 文件、字段表、方法表都可以携带自己的属性表集合，描述场景的专有信息
2. 与 Class 的严格要求不同，属性表集合的限制稍微宽松一些，虚拟机会忽略掉它不认识的属性
3. Code 属性是 Class 文件最重要的部分，Java 程序可以简单的分为两部分：代码 Code、元数据
4. 了解 Code 属性是学习字节码执行引擎内容的必要基础，能够阅读字节码也是基本技能



Code 属性结构实例：

<img src="https://pcloud-1258173945.cos.ap-guangzhou.myqcloud.com/uPic/image-20220303180825635.png" alt="image-20220303180825635" style="zoom:50%;" />



### 字节码指令简介

🌟 简介完全看不懂，这里就跳过去了。。

🌟 小章节也基本看不懂，先速读好了，大概记录一下，等想深究的时候再回来看看



#### 字节码与数据类型

1. 阅读字节码是了解 Java 虚拟机的基本技能，是一项应当熟练掌握的能力
2. 如果希望了解更详细的信息，可以阅读由 Oracle 官方授权的，周志明翻译的《Java 虚拟机规范（Java SE 7）》中文版



#### 同步指令

1. 同步指令集序列由 `synchronized` 语句来表示，在虚拟机中有 `monitorenter`、`monitorexit` 指令来支持
2. 方法中调用过的每条 `monitorenter` 都必须有其对应的 `monitorexit` 指令



来看一段编译后的同步代码：

<img src="https://pcloud-1258173945.cos.ap-guangzhou.myqcloud.com/uPic/image-20220303213843479.png" alt="image-20220303213843479" style="zoom:50%;" />



#### Class 结构的发展

1. Class 文件结构发布超过二十年，这二十多年 Java 技术体系有翻天覆地的变化，但是 Class 文件结构一直比较稳定，几乎没有更变
2. 仅仅在文件格式的改进，标志，属性表这些设计上扩展新内容而已
3. Class 文件格式的扩展，大部分用于支持 Java 中许多语言特性，例如枚举，变长参数，泛型，动态注解等等
4. Class 文件具备的平台中立，紧凑，稳定和可扩展性的特点，是 Java 技术体系的重要支柱



## 虚拟机的类加载机制

1. Class 文件的所有信息最终都会被加载到虚拟机才能被运行和使用
2. Java 里面类型加载、连接和初始化都是在程序运行期间完成的，这种策略让 Java 牺牲了提前编译的能力和增加类加载的开销，但是为 Java 应用提供了扩展性和灵活性，例如 AOP，IOC，反射等特性都依赖动态加载的能力实现的



### 类加载的时机

类加载的七个阶段，也称类的生命周期，如图：

<img src="https://pcloud-1258173945.cos.ap-guangzhou.myqcloud.com/uPic/image-20220303215449319.png" alt="image-20220303215449319" style="zoom:50%;" />



加载阶段：在《Java 虚拟机规范》中没有强制约束，由虚拟机的实现自由把握

初始化阶段：《Java 虚拟机规范》严格规定以下六种情况必须对类进行初始化：

1. 遇到 new、getstatic、putstatic、invokestatis 这四条指令的时候
2. 使用 java.lang.reflect 的方法对类型进行反射的时候
3. 初始化类的时候，先触发父类的初始化
4. 虚拟机启动的时候，会先去初始化主类
5. 关于 JDK 7 新加入的动态语言支持。。等
6. JDK 8 接口中定义的默认方法时，初始化该接口



要点：

1. 对于静态字段只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化



### 类的加载过程

#### 第一步：加载

加载 Loading 的三个过程：

1. 通过类的全限定名来获取定义此类的二进制字节流
2. 将字节流的静态存储结构转化为方法区的运行时数据结构
3. 在内存中生成 java.lang.Class 对象



虚拟机并没有限定从哪里获取二进制字节流，给充满创造力的开发者许多发挥空间，例如：

1. 从 zip 包中读取字节流，这是 JAR，WAR 格式的基础
2. 从网络中获取，典型场景是 Web Applet 的应用
3. 运行时计算生成，这是动态代理技术的基础，典型应用就是 java.lang.reflect.Proxy
4. …………



#### 第二步：验证

为什么要验证 ？

1. 验证阶段的目的是确保 Class 文件信息《Java 虚拟机规范》符合规范和安全
2. 任何危险的操作都会被编译器无情的抛出异常，拒绝编译。这是 Java 安全编程的基础
3. Java 虚拟机如果不检查输入的字节流，对其完全信任的话，很可能会因为载入了有错误或有恶意企图的字节码流而导致整个系统受攻击甚至崩溃



验证大致的四个阶段动作：

1. 文件格式验证：验证格式规范，包括：魔数、版本号、常量池、等等……
2. 元数据验证：验证语义分析，包括：父类，集成，抽象，字段，等等…………
3. 字节码验证：验证程序语义和逻辑，包括：Code 属性，指针跳转检查，方法体的内容，等等…… 
4. 符号引用验证：符号引用的有效性，指定类的规范，字段、方法的可访问性



结论：

1. 验证阶段非常重要，但不是必须要执行的阶段。
2. 如果程序已经被反复验证过（例如 Eclipse）安全性，可以考虑使用 `-Xverify:none` 关闭类的验证措施，来缩短虚拟机加载时间



#### 第三步：准备

